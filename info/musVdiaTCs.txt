Alignable
Enveloped
Parametric
HasOrigin
DomainBounds, Sectionable
Transformable
Traced
TrailLike


atParam 	 :: p -> Scalar (V p) -> Codomain p
moveOriginTo :: Point (V t) -> t -> t


domainLower :: p -> Scalar (V p)
domainUpper :: p -> Scalar (V p)

splitAtParam :: p -> Scalar (V p) -> (p, p)
section :: p -> Scalar (V p) -> Scalar (V p) -> p
reverseDomain :: p -> p

transform :: Transformation (V t) -> t -> t

trailLike :: Located (Trail (V t)) -> t



------------------------------------------------------------------------

type Transformation v = (v :-: v, v)                         x

-- XXX How does this work if whole thing is outside origin?
type Envelope v = (Option (v -> Max (Scalar v)))

type Trace v    = Point v -> v -> Data.Monoid.Inf.PosInf (Scalar v)

class Juxtaposable where
    -- Usually defined in terms of Enveloped/HasOrigin (could be Enveloped/Transformable)

class Enveloped where -- Defines boundary (from origin)
	getEnvelope :: a -> Envelope (V a)
	
class HasTrace  where -- Defines boundary (from arbitary point, a ray tracer)
	getTrace :: a -> Trace (V a)
	
class Alignable where -- Moves origin to boundary (interpolating)
	alignBy ::
	  V a -> Scalar (V a) -> a -> a
	

------------------------------------------------------------------------

type Transformation v = (v :-: v, v)

Transformable a
    -- How to transform only time, only space etc?
	transform :: Transformation (V a) -> a -> a
HasDuration a
	duration :: a -> D a
HasPosition a
	position :: a -> Scalar (D a) -> Option (T a) -- compare alerp and enveloped
Reversible
    reverse :: a -> a
Splittable a
    -- split at give point, retaining given duration
	take :: T -> a -> a
	drop :: D -> a -> a
	splitAt :: D -> a -> (a, a)



